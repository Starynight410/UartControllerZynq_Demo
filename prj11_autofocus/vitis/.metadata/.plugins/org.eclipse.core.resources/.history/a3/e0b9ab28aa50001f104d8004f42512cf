#include "xparameters.h"
#include "xuartns550.h"
#include "xil_printf.h"
#include "sleep.h"
#include "xgpiops.h"
#include "xuartps.h"
#include "xspips.h"
#include "xiicps.h"
#include "xplatform_info.h"
#include "string.h"
#include "xgpiops.h"
#include <stdio.h>
#include "xscugic.h"
#include "xuartps.h"


XGpioPs gXGpioLed1;
XGpioPs gXGpioLed2;
#define EMIOLED1    54
#define EMIOLED2    55

/************************** Constant Definitions *****************************/

/*
 * The following constants map to the XPAR parameters created in the
 * xparameters.h file. They are defined here such that a user can easily
 * change all the needed parameters in one place.
 */
#define UART_DEVICE_ID		XPAR_UARTNS550_0_DEVICE_ID

/**************************** Type Definitions *******************************/


/***************** Macros (Inline Functions) Definitions *********************/


/************************** Function Prototypes ******************************/
int UartNs550HelloWorldExample(u16 DeviceId);
u8 order_rec();

/************************** Variable Definitions *****************************/
// Uart define
XUartNs550 UartNs550;		/* The instance of the UART Driver */

// SPI define
XSpiPs Spi0, Spi1;
#define SpiPs_RecvByte(BaseAddress) \
		(u8)XSpiPs_In32((BaseAddress) + XSPIPS_RXD_OFFSET)

#define SpiPs_SendByte(BaseAddress, Data) \
		XSpiPs_Out32((BaseAddress) + XSPIPS_TXD_OFFSET, (Data))

int spi0_init();
void spi0_one_write();
void SpiRead(int ByteCount);
void SpiWrite(u8 *Sendbuffer, int ByteCount);

int UartNs550HelloWorldExample(u16 DeviceId);
u8 order_rec();

unsigned char ReadBuffer[1024];
unsigned char WriteBuffer[1024]={1,2,3,4,5,6,7,8,9,0};
/*****************************************************************************/
/**
* Main function to call the example.
*
*
* @return
*		- XST_FAILURE if the Test Failed.
*		- A non-negative number indicating the number of
*		characters sent.
*
* @note		None.
*
******************************************************************************/

int main(void)
{
	int Status;

	/*
	 * Run the UartNs550 example, specify the the Device ID that is
	 * generated in xparameters.h
	 */


	Status = UartNs550HelloWorldExample(UART_DEVICE_ID);

	if (Status == XST_FAILURE) {
		xil_printf("Uartns550 hello world Example Failed\r\n");
		return XST_FAILURE;
	}

	xil_printf("Successfully ran Uartns550 hello world Example\r\n");
	return Status;
}


/******************************************************************************/
/**
*
* This function sends Hello World with the UART 16450/550 device and driver as
* a design example. The purpose of this function is to illustrate how to use
* the XUartNs550 driver.
*
* This function polls the UART and does not require the use of interrupts.
*
* @param	DeviceId is the XPAR_<UARTNS550_instance>_DEVICE_ID value from
*		xparameters.h
*
* @return
*		- XST_FAILURE if the UART driver could not be initialized
*		successfully.
*		- A non-negative number indicating the number of characters
*		sent.
*
* @note		None.
*
****************************************************************************/
//通信协议：$ w 0 1 a
//w代表写
//0为地址
//1为数据
//地址==1时为灯操作，数据为1时开灯，数据为0时关灯
//地址==2时为写数据操作，

//读数据时，返回格式为$ 2 b
//读写命令空格都要计算在内

u8 HelloWorld[11]="HelloWorld\n";
u8 order_buf[9]={0};		//保存命令
u8 order_cnt=0;				//数组计数器
int UartNs550HelloWorldExample(u16 DeviceId)
{
	u8  sendbuf[5]={'$',' ',2,' ','b'};
	u8  rec_cnt=0;
	int SentCount = 0;
	int Status;
	XGpioPs_Config *ConfigPtr;

    //GPIO LED 初始化
    ConfigPtr = XGpioPs_LookupConfig(XPAR_XGPIOPS_0_DEVICE_ID);
	Status = XGpioPs_CfgInitialize(&gXGpioLed1, ConfigPtr, ConfigPtr->BaseAddr);
	if (Status != XST_SUCCESS)  return XST_FAILURE;
	Status = XGpioPs_CfgInitialize(&gXGpioLed2, ConfigPtr, ConfigPtr->BaseAddr);
	if (Status != XST_SUCCESS)  return XST_FAILURE;
	XGpioPs_SetDirectionPin(&gXGpioLed1, EMIOLED1, 1);
	XGpioPs_SetOutputEnablePin(&gXGpioLed1, EMIOLED1, 1);

	XGpioPs_SetDirectionPin(&gXGpioLed2, EMIOLED2, 1);
	XGpioPs_SetOutputEnablePin(&gXGpioLed2, EMIOLED2, 1);
	
	// Initialize the UartNs550 device so that it is ready to use
	//波特率每次更新硬件后，手动改为115200
	Status = XUartNs550_Initialize(&UartNs550, DeviceId);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}
	xil_printf("Initiate Uart and LED succeed\r\n");
	XGpioPs_WritePin(&gXGpioLed1, EMIOLED1, 1);	//手动点灯

	// SPI test
	int Status_spi;
	int i_spi, j_spi;
	int value;
	xil_printf("SPI Selftest Example \r\n");

	Status_spi = spi0_init();
	if (Status_spi != XST_SUCCESS) {
		xil_printf("SPI Selftest Example Failed\r\n");
		return XST_FAILURE;
	}

	while(1)
	{
//		 usleep(100);
//		 XUartNs550_Send(&UartNs550,&HelloWorld[SentCount], sizeof(HelloWorld));

		rec_cnt = order_rec();
		if(rec_cnt==1)
		{
			rec_cnt = 0;
			if(order_buf[2]=='w')			//写入命令
			{
				if(order_buf[4]=='1')		//操作灯命令
				{
					XGpioPs_WritePin(&gXGpioLed1, EMIOLED1, order_buf[6]);
				}
				else if(order_buf[4]=='2')	//写入数据
				{
					Xil_Out32((XPAR_AAVMMBASE_BASEADDR + 300), (order_buf[6]-0x30));
				}
				else if(order_buf[4]=='3')	//SPI test
				{
					for (i_spi = 0; i_spi < 6; i_spi++)	//重复发6遍
					{
						SpiWrite(WriteBuffer, 10);
						SpiRead(10);
						XUartNs550_Send(&UartNs550, ReadBuffer, sizeof(ReadBuffer));
						memset(ReadBuffer, 0x00, 1024);
						sleep(1);
					}
//					xil_printf("Successfully ran SPI Selftest Example\r\n");
				}
			}
			else if(order_buf[2]=='r')		//读取命令
			{
				sendbuf[2] = Xil_In32(XPAR_AAVMMBASE_BASEADDR + 300)+0x30;
				XUartNs550_Send(&UartNs550,&sendbuf[0], sizeof(sendbuf));
			}
			memset(order_buf,0,sizeof(order_buf));
		}
		
	
	}


	return SentCount;
}


//读取串口接收数据，每一个值都保存到全局数组order_buf中
//接收完一条命令后返回1，其他返回0
u8 order_rec()
{
	u8 rec_buf[1]={0};
	u8 rec_mark=0;
	rec_mark = XUartNs550_Recv(&UartNs550,&rec_buf[0],1);
	if(rec_mark!=0)
	{
		order_buf[order_cnt]=rec_buf[0];
		if(order_cnt==8)
		{
			order_cnt=0;
			return 1;
		}	
		else
		{
			order_cnt++;
			return 0;
		}
	}
	return 0;
}


// ==============================SPI Function==============================
void SpiRead(int ByteCount)
{
	int Count;
	u32 StatusReg;

	StatusReg = XSpiPs_ReadReg(Spi0.Config.BaseAddress,
					XSPIPS_SR_OFFSET);

	/*
	 * Polling the Rx Buffer for Data
	 */
	do{
		StatusReg = XSpiPs_ReadReg(Spi0.Config.BaseAddress,
					XSPIPS_SR_OFFSET);
	}while(!(StatusReg & XSPIPS_IXR_RXNEMPTY_MASK));

	/*
	 * Reading the Rx Buffer
	 */
	for(Count = 0; Count < ByteCount; Count++){
		ReadBuffer[Count] = SpiPs_RecvByte(
				Spi0.Config.BaseAddress);
	}

}

void SpiWrite(u8 *Sendbuffer, int ByteCount)
{
	u32 StatusReg;
	int TransCount = 0;

	StatusReg = XSpiPs_ReadReg(Spi0.Config.BaseAddress,
				XSPIPS_SR_OFFSET);

	while ((ByteCount > 0) &&
		(TransCount < XSPIPS_FIFO_DEPTH)) {
		SpiPs_SendByte(Spi0.Config.BaseAddress,
				*Sendbuffer);
		Sendbuffer++;
		++TransCount;
		ByteCount--;
	}

	/*
	 * Wait for the transfer to finish by polling Tx fifo status.
	 */
	do {
		StatusReg = XSpiPs_ReadReg(
				Spi0.Config.BaseAddress,
					XSPIPS_SR_OFFSET);
	} while ((StatusReg & XSPIPS_IXR_TXOW_MASK) == 0);

}

int spi0_init() {
	int Status;
	XSpiPs_Config *SpiConfig;

	/*
	 * Initialize the SPI device.
	 */
	SpiConfig = XSpiPs_LookupConfig(XPAR_XSPIPS_0_DEVICE_ID);
	if (NULL == SpiConfig) {
		return XST_FAILURE;
	}

	Status = XSpiPs_CfgInitialize(&Spi0, SpiConfig, SpiConfig->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Perform a self-test to check hardware build.
	 */
	Status = XSpiPs_SelfTest(&Spi0);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}
	xil_printf("%s self test succ\r\n", __func__);

	Status = XSpiPs_SetOptions(&Spi0, XSPIPS_MASTER_OPTION);
	if (Status != XST_SUCCESS) {
		xil_printf("%s XSpiPs_SetOptions fail\n", __func__);
		return XST_FAILURE;
	}
	Status = XSpiPs_SetClkPrescaler(&Spi0, XSPIPS_CLK_PRESCALE_64);
	if (Status != XST_SUCCESS) {
		xil_printf("%s XSpiPs_SetClkPrescaler fail\n", __func__);
		return XST_FAILURE;
	}
	XSpiPs_Enable(&Spi0);
	xil_printf("spi 0 config finish\n");
	return XST_SUCCESS;
}

